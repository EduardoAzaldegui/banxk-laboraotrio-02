pipeline {
  agent any

  environment {
    // === CONFIGURACI√ìN DEL DIRECTORIO ===
    // Nombre de la carpeta donde est√° el c√≥digo (ej. card-ops-producer)
    PROJECT_DIRECTORY = "card-ops-producer"

    // Variables de Jenkins
    GITHUB_REPO_URL_PRODUCER = "${GITHUB_REPO_URL_PRODUCER}"
    GITHUB_BRANCH_PRODUCER = "${GITHUB_BRANCH_PRODUCER}"
    APP_ENVIRONMENT = "${APP_ENVIRONMENT}"
    APP_PORT = "8085"
    JAVA_VERSION = "${JAVA_VERSION}"
    COMPOSE_FILE = "${APP_COMPOSE_FILE}"
  }

  stages {

    stage('üîç Verificar Entorno Java') {
        steps {
            script {
                // Esto puede correr en la ra√≠z, no afecta
                sh '''
                echo "=== DIAGN√ìSTICO DE JAVA ==="
                java -version
                echo "JAVA_HOME: $JAVA_HOME"
                echo "==========================="
                '''
            }
        }
    }

    stage('üîç Preparaci√≥n') {
      steps {
        echo "üöÄ Iniciando despliegue: ${GITHUB_REPO_URL_PRODUCER}"
        echo "üìÇ Directorio de trabajo: ${PROJECT_DIRECTORY}"
        cleanWs() // Limpia todo el workspace
      }
    }

    stage('üì• Clonar Repositorio') {
      steps {
        script {
          // Clonamos en la ra√≠z del workspace (esto crea la carpeta card-ops-producer)
          echo "üì¶ Clonando repositorio..."
          git branch: GITHUB_BRANCH_PRODUCER,
              credentialsId: 'github-token',
              url: GITHUB_REPO_URL_PRODUCER

          sh 'ls -la' // Para verificar que la carpeta se baj√≥
        }
      }
    }

    stage('üîß Pre-Deploy') {
      steps {
        // USAMOS dir() PARA ENTRAR A LA CARPETA
        dir(env.PROJECT_DIRECTORY) {
            script {
              echo "üõ†Ô∏è Preparando despliegue en: ${PROJECT_DIRECTORY}..."
              sh '''
                echo "üìã Verificando estructura en $(pwd)..."
                ls -la

                if [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
                  echo "‚úÖ Archivo de construcci√≥n encontrado"
                else
                  echo "‚ùå ERROR: No se encontr√≥ pom.xml/build.gradle en $(pwd)"
                  exit 1
                fi

                if [ -f "docker-compose.yml" ]; then
                  echo "‚úÖ docker-compose.yml encontrado"
                else
                  echo "‚ùå ERROR: docker-compose.yml no encontrado en $(pwd)"
                  exit 1
                fi

                # Verificar puerto
                echo "üîç Verificando puerto ${APP_PORT}..."
                if netstat -tuln | grep -q ":${APP_PORT}"; then
                  echo "‚ö†Ô∏è Puerto ${APP_PORT} ya en uso (se liberar√° al bajar docker)"
                else
                  echo "‚úÖ Puerto ${APP_PORT} disponible"
                fi
              '''

              sh '''
                echo "üõë Deteniendo servicios existentes (si los hay)..."
                # Es importante correr esto aqu√≠ para que encuentre el docker-compose.yml correcto
                docker compose down || echo "No services running"
              '''
            }
        }
      }
    }

    stage('üßπ Limpieza Docker') {
      steps {
        dir(env.PROJECT_DIRECTORY) {
            script {
              echo "üßπ Limpiando recursos Docker..."
              sh '''
                # Parar y eliminar contenedores asociados a este compose
                docker compose down --remove-orphans --rmi all || true

                # Limpieza general segura
                docker container prune -f
                docker image prune -a -f
              '''
            }
        }
      }
    }

    stage('üèóÔ∏è Construir Aplicaci√≥n Java') {
      steps {
        dir(env.PROJECT_DIRECTORY) {
            script {
              echo "üì¶ Construyendo JAR dentro de ${PROJECT_DIRECTORY}..."
              sh '''
                if [ -f "pom.xml" ]; then
                  echo "üî® Usando Maven..."
                  chmod +x ./mvnw || true
                  # Usamos ./mvnw si existe, sino mvn del sistema
                  if [ -f "./mvnw" ]; then
                    ./mvnw clean package -DskipTests --batch-mode
                  else
                    mvn clean package -DskipTests --batch-mode
                  fi
                  ls -la target/*.jar
                elif [ -f "build.gradle" ]; then
                  echo "üî® Usando Gradle..."
                  chmod +x ./gradlew
                  ./gradlew build -x test
                  ls -la build/libs/*.jar
                fi
              '''
            }
        }
      }
    }


    stage('üöÄ Desplegar App Java') {
      steps {
        dir(env.PROJECT_DIRECTORY) {
            script {
              echo "üöÄ Desplegando desde ${PROJECT_DIRECTORY}..."

              // Eliminamos contenedor forzosamente por nombre si existe
              sh 'docker rm -f java-app 2>/dev/null || true'

              sh '''
                echo "üì¶ IP configurada: ${PEKKO_HOST}"
                export PEKKO_HOST=${PEKKO_HOST}

                # Construir imagen fresca
                docker compose build --no-cache --pull --build-arg JAVA_VERSION=${JAVA_VERSION}

                # Levantar servicio
                docker compose up -d java-app

                echo "‚úÖ Aplicaci√≥n desplegada en puerto ${APP_PORT}"
              '''
            }
        }
      }
    }

    stage('üè• Health Check') {
      steps {
        // Necesitamos estar en el directorio para usar "docker compose logs" correctamente
        dir(env.PROJECT_DIRECTORY) {
            script {
              echo "üîç Health Check..."
              sh '''
                echo "‚è≥ Esperando endpoint /actuator/health..."
                MAX_RETRIES=18
                attempt=1

                # Obtener ID del contenedor usando el compose del directorio actual
                CONTAINER_ID=$(docker compose ps -q java-app)

                if [ -z "$CONTAINER_ID" ]; then
                   echo "‚ùå No se encontr√≥ el contenedor java-app."
                   exit 1
                fi

                while [ $attempt -le $MAX_RETRIES ]; do
                  status=$(docker inspect -f '{{.State.Health.Status}}' $CONTAINER_ID 2>/dev/null || echo "unknown")
                  echo "Estado: $status"

                  if [ "$status" = "healthy" ]; then
                    echo "‚úÖ App saludable."
                    exit 0
                  fi

                  if [ "$status" = "unhealthy" ]; then
                    echo "‚ùå App marcada como UNHEALTHY."
                    docker compose logs --tail=50 java-app
                    exit 1
                  fi

                  sleep 10
                  attempt=$((attempt + 1))
                done

                echo "‚ùå Timeout esperando health check."
                docker compose logs --tail=50 java-app
                exit 1
              '''
            }
        }
      }
    }

    stage('üìã Ver Logs en Servidor') {
      steps {
        // No necesitamos estar en el directorio para esto si usamos docker cp con el nombre del contenedor,
        // pero por consistencia lo dejamos, aunque el contenedor 'java-app' es global en docker.
        script {
           sh '''
             mkdir -p /shared-logs/pluggyLogs/build/
             docker cp java-app:/app/logs/. /shared-logs/pluggyLogs/build/ 2>/dev/null || echo "‚ÑπÔ∏è Sin logs nuevos"
             ls -la /shared-logs/pluggyLogs/build/ || true
           '''
        }
      }
    }
  }

  post {
    always {
      script {
        cleanWs()
      }
    }
    success {
        script {
            echo "‚úÖ Despliegue de ${PROJECT_DIRECTORY} Exitoso"
        }
    }
    failure {
        script {
            // Entramos al directorio para sacar logs del compose espec√≠fico
            dir(env.PROJECT_DIRECTORY) {
                echo "‚ùå Falla en despliegue"
                sh 'docker compose logs --tail=100 java-app || true'
                sh 'docker compose ps -a || true'
            }
        }
    }
  }
}